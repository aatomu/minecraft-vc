<!DOCTYPE html>

<head>
  <title>Title</title>
  <style>
    .body {
      text-align: center;
    }
  </style>
</head>

<body>
  <button id="start">Start</button>
  <span id="message"></span>
</body>
<script>
  // Global variables
  const start = document.getElementById("start")
  const message = document.getElementById("message")
  let audioCtx = undefined
  const sampleRate = 44100
  const inputBufferTime = 100
  let buffer = []
  let users = {}

  // Websocket initialize
  console.log("Global initialize")
  const url = new URL(window.location.href)
  const params = new URLSearchParams(url.searchParams)
  const id = params.get("id")
  if (!id) {
    start.setAttribute("disabled", "true")
    message.innerText = "Required MCID parameter."
  }


  async function NewConnection() {
    console.log("Click new connection")

    // Websocket initialize
    console.log("Websocket initialize")
    const ws = new WebSocket(`./websocket?id=${id}`)
    ws.binaryType = "arraybuffer"
    let isClosed = false
    ws.addEventListener("open", () => {
      console.log("Websocket: open")
      setInterval(() => {
        if (isClosed) return

        ws.send(new Float32Array(buffer))
        buffer = []

      }, inputBufferTime)
    })
    ws.addEventListener("message", (e) => {
      if (!e.data) return
      let arr = e.data
      // ID
      const idLen = new Uint16Array(arr.slice(0, 2))[0]
      arr = arr.slice(2)
      const id = new TextDecoder("utf-8").decode(arr.slice(0, idLen))
      arr = arr.slice(idLen)
      // Gain
      const gain = new Float32Array(arr.slice(0, 4))[0]
      arr = arr.slice(4)
      // PCM
      const pcm = new Float32Array(arr)
      console.log(`idLen=${idLen}, id=${id}, gain=${gain}`)

      // User Initialize 
      if (!(id in users)) {
        console.log(`User(${id}) initialize`)
        users[id] = {
          serverGainNode: audioCtx.createGain(),
          clientGainNode: audioCtx.createGain(),
          schedule: audioCtx.currentTime,
        }
        users[id].serverGainNode.connect(users[id].clientGainNode)
        users[id].clientGainNode.connect(audioCtx.destination)
      }
      users[id].serverGainNode.gain.linearRampToValueAtTime(gain, audioCtx.currentTime + (inputBufferTime / 1000))

      playAudioStream(id, pcm)
    })
    ws.addEventListener("error", (e) => {
      console.log(`Websocket: error`, e)
    })
    ws.addEventListener("close", (e) => {
      console.log("Websocket: close", e)
      if (e.code == 400) {
        message.innerText = "Connection close: multi login is not allowed."
      } else {
        message.innerText = `Connection close: ${e.reason}(code:${e.code})`
      }
      isClosed = true
    })

    // Audio API initialize
    console.log("Audio API initialize")
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: sampleRate });
    const inputGainNode = audioCtx.createGain()
    inputGainNode.gain.value = 3
    await audioCtx.audioWorklet.addModule(`./getPcmProcessor.js?t=${new Date()}`)
    const getPcmNode = new AudioWorkletNode(audioCtx, "get-pcm-processor")
    getPcmNode.port.onmessage = (e) => {
      if (isClosed) return

      buffer.push(...Array.from(e.data))
    }

    console.log("Get Voice stream")
    const media = await navigator.mediaDevices.getUserMedia({
      audio: {
        sampleRate: sampleRate,
      },
      video: true,
    })
    console.log("Media:", media)
    const track = audioCtx.createMediaStreamSource(media)
    console.log("Track:", track)
    track.connect(inputGainNode)
    inputGainNode.connect(getPcmNode)
    console.log("Connected track => getPcmNode")
  }

  start.addEventListener("click", NewConnection)


  function playChunk(audio_src, scheduled_time) {
    if (audio_src.start) {
      audio_src.start(scheduled_time);
    } else {
      audio_src.noteOn(scheduled_time);
    }
  }

  function playAudioStream(id = "id", pcm = new Float32Array()) {
    const buffer = audioCtx.createBuffer(1, pcm.length, sampleRate)
    const source = audioCtx.createBufferSource()
    const currentTime = audioCtx.currentTime;

    buffer.getChannelData(0).set(pcm);

    source.buffer = buffer;
    source.connect(users[id].serverGainNode);

    if (currentTime < users[id].schedule) {
      playChunk(source, users[id].schedule);
      users[id].schedule += buffer.duration;
    } else {
      playChunk(source, currentTime);
      users[id].schedule = currentTime + buffer.duration;
    }
  }
</script>